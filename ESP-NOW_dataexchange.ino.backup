#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h>

#include <LittleFS.h>
#include <FS.h>

#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>
#include <ArduinoJson.h>
#include "Motion.h"
#include "esp_wifi_types.h"        // â† è¿½åŠ ï¼ˆMACãƒ˜ãƒƒãƒ€ã®å‹ï¼‰

// ==== LEDãƒãƒˆãƒªã‚¯ã‚¹è¨­å®š ====
#define LED_PIN   14
#define W 8
#define H 8
#define NUM_LEDS (W*H)
#define PIXEL_TYPE (NEO_GRB + NEO_KHZ800)
#define GLOBAL_BRIGHTNESS 10

Adafruit_NeoMatrix matrix(
  W, H, LED_PIN,
  NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_PROGRESSIVE,
  PIXEL_TYPE
);

// Motion.cppã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã®å‚ç…§
Adafruit_NeoMatrix& Matrix = matrix;

// ===== ç„¡ç·šè¨­å®š =====
static const int WIFI_CH = 6;               // ä¸¡ç«¯ã§åˆã‚ã›ã‚‹
static const uint8_t MAC_BC[6] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

// ===== LittleFS =====
static const char* JSON_PATH = "/my_data_text.json";

// ===== ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¸Šé™ãƒ»ãƒãƒ£ãƒ³ã‚¯ =====
// [STAB] ãƒãƒ£ãƒ³ã‚¯ã‚’å°‘ã—å°ã•ãï¼ˆ200â†’160Bï¼‰ã—ã¦æå¤±ç‡ã‚’ä¸‹ã’ã‚‹
static const size_t MAX_MSG_BYTES   = 2048;     // 2KBã¾ã§ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¢—ã‚„ã›ã‚‹ï¼‰
static const size_t CHUNK_DATA_MAX  = 160;      // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã®å®Ÿãƒ‡ãƒ¼ã‚¿ï¼ˆå®‰å®šåŒ–ï¼‰
static const size_t MAX_CHUNKS      = (MAX_MSG_BYTES + CHUNK_DATA_MAX - 1) / CHUNK_DATA_MAX;

// ===== ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰ =====
enum MsgType : uint8_t { HELLO=1, META=2, CHUNK=3, NACK=4, ACK=5, TURN=6 };

struct __attribute__((packed)) FrameMeta {
  uint8_t  type;          // META
  uint16_t msg_id;        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è­˜åˆ¥
  uint16_t total;         // ãƒãƒ£ãƒ³ã‚¯ç·æ•°
  uint16_t len_all;       // å…¨ä½“é•·
  uint32_t crc32_all;     // å…¨ä½“CRC
};

struct __attribute__((packed)) FrameChunk {
  uint8_t  type;          // CHUNK
  uint16_t msg_id;
  uint16_t idx;           // 0..total-1
  uint16_t payload_len;   // dataé•·
  uint8_t  data[CHUNK_DATA_MAX];
};

struct __attribute__((packed)) FrameHello { uint8_t  type; };
struct __attribute__((packed)) FrameAck   { uint8_t  type; uint16_t msg_id; };
struct __attribute__((packed)) FrameNack  { uint8_t  type; uint16_t msg_id; uint16_t missing_idx; };
struct __attribute__((packed)) FrameTurn  { uint8_t  type; uint16_t msg_id; };

// ===== çŠ¶æ…‹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ»ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶ï¼‰ =====
static bool hasPeer = false;      // ç›¸æ‰‹ç¢ºå®š
static bool isInitiator = false;  // è‡ªåˆ†ã¯é€ä¿¡å´ã‹ï¼Ÿï¼ˆMACæ¯”è¼ƒã§æ±ºå®šï¼‰
static bool txRight = false;      // é€ä¿¡æ¨©ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³æ‰€æŒï¼‰
static bool txLaunched = false;   // é€ä¿¡ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹æ¸ˆã¿ãƒ•ãƒ©ã‚°
uint8_t peerMac[6] = {0};
unsigned long lastHelloMs = 0;
bool broadcastPeerAdded = false;

// è‡ªãƒãƒ¼ãƒ‰é€ä¿¡ãƒ‡ãƒ¼ã‚¿ï¼ˆLittleFSã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ï¼‰
String   myJson;

// é€ä¿¡å´çŠ¶æ…‹
uint16_t current_msg_id = 1;
String   tx_json;
uint32_t tx_crc = 0;
uint16_t tx_total = 0;
uint16_t tx_len_all = 0;
bool     tx_done = false;
bool     tx_meta_sent = false;  // METAã‚’æœ¬å½“ã«é€ã£ãŸã‹
unsigned long lastSendMs = 0;
unsigned long lastProgressMs = 0;    // é€²æ—ç›£è¦–
uint16_t nextIdx = 0;                // æ¬¡ã«æŠ•ã’ã‚‹ãƒãƒ£ãƒ³ã‚¯

// ACKå†é€ç”¨ï¼ˆResponderå´ã§TURNå¾…ã¡æ™‚ã«ä½¿ç”¨ï¼‰
static unsigned long lastAckSentAt = 0;
static uint16_t lastAckMsgId = 0;

// [STAB] NACKãƒ‡ãƒ‡ãƒ¥ãƒ¼ãƒ—ç”¨ï¼ˆåŒã˜msg/idxã®é€£æ‰“ã‚’æŠ‘æ­¢ï¼‰
static uint16_t lastNackIdx = 0xFFFF;
static uint16_t lastNackMsg = 0xFFFF;
static unsigned long lastNackAt = 0;

// å—ä¿¡å´ï¼ˆã‚¢ã‚»ãƒ³ãƒ–ãƒªï¼‰çŠ¶æ…‹
struct RxState {
  bool     active = false;
  uint16_t msg_id = 0;
  uint16_t total  = 0;
  uint16_t len_all= 0;
  uint32_t crc32_all = 0;
  bool     got[MAX_CHUNKS];
  uint16_t gotCount = 0;
  uint8_t  buf[MAX_MSG_BYTES];
  // [STAB] å—ä¿¡å´ã‹ã‚‰NACKã‚’é€ã‚‹é »åº¦ã‚’æŠ‘åˆ¶
  unsigned long lastNackTxAt = 0;
  uint16_t      lastNackTxIdx = 0xFFFF;
} rx;

// LEDè¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼ï¼ˆ5ç§’å¾Œã«æ¶ˆç¯ï¼‰
unsigned long ledDisplayUntil = 0;

// === Rendezvous/Keepalive è¨­å®š ===
static const unsigned long FOUND_LOG_DEBOUNCE = 5000;  // 5ç§’ã«1å›ã ã‘ãƒ­ã‚°å‡ºåŠ›ï¼ˆã‚¹ãƒ‘ãƒ é˜²æ­¢ï¼‰

// æœ€çµ‚ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯æ™‚åˆ»ï¼ˆä½•ã‹å—ä¿¡ã—ãŸ/é€ä¿¡ã—ãŸï¼‰
static unsigned long lastTrafficMs = 0;
// ç›¸æ‰‹ç™ºè¦‹ãƒ­ã‚°ã®å‡ºã—éãé˜²æ­¢
static unsigned long lastFoundLogMs = 0;

// === RSSI è¨­å®šï¼ˆMACã”ã¨ã«è¨˜éŒ²ãƒ»é–‹å§‹æ™‚ã®ã¿åˆ¤å®šï¼‰ ===
static const int RSSI_THRESHOLD = -65;  // äº¤æ›é–‹å§‹æ™‚ã®é–¾å€¤

// RSSIã‚’MACã”ã¨ã«è¨˜éŒ²ï¼ˆç›´è¿‘ã®ã¿ï¼‰
struct RssiEntry { uint8_t mac[6]; int rssi; unsigned long at; };
static RssiEntry gRssi[6]; // è¿‘å ´ãªã‚‰6æ ã§ååˆ†

static int findRssiIndex(const uint8_t mac[6]) {
  for (int i=0;i<6;i++) {
    if (memcmp(gRssi[i].mac, mac, 6)==0) return i;
  }
  return -1;
}

static void upsertRssi(const uint8_t mac[6], int rssi){
  int i = findRssiIndex(mac);
  if (i<0) { // ç©ºãã‚’æ¢ã™ or æœ€å¤ã‚’ä¸Šæ›¸ã
    unsigned long oldestAt=0xFFFFFFFF; int idx=0;
    for (int k=0;k<6;k++){ 
      if (gRssi[k].at < oldestAt){ 
        oldestAt=gRssi[k].at; idx=k; 
      } 
    }
    memcpy(gRssi[idx].mac, mac, 6); 
    gRssi[idx].rssi=rssi; 
    gRssi[idx].at=millis(); 
    return;
  }
  gRssi[i].rssi = rssi; 
  gRssi[i].at=millis();
}

static bool getRssiForMac(const uint8_t mac[6], int* out){
  int i = findRssiIndex(mac);
  if (i<0) return false;
  *out = gRssi[i].rssi; 
  return true;
}

static int lastRSSI = 0;                // æœ€å¾Œã«å—ä¿¡ã—ãŸRSSIå€¤ï¼ˆå¾Œæ–¹äº’æ›ï¼‰
static bool rssiFilterEnabled = true;   // RSSIãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æœ‰åŠ¹/ç„¡åŠ¹

// ç›´è¿‘ã§è¦³æ¸¬ã—ãŸé€ä¿¡å…ƒMACï¼ˆã‚¹ãƒ‹ãƒ•ã‚¡ã§æ›´æ–°ï¼‰
static uint8_t lastRssiMac[6] = {0};
static volatile bool lastRssiValid = false;

// 802.11 MACãƒ˜ãƒƒãƒ€ã®ç°¡æ˜“æ§‹é€ ä½“ï¼ˆé€ä¿¡å…ƒ = addr2ï¼‰
typedef struct {
  uint16_t frame_ctrl;
  uint16_t duration_id;
  uint8_t  addr1[6];
  uint8_t  addr2[6];   // â† é€ä¿¡å…ƒ
  uint8_t  addr3[6];
  uint16_t seq_ctrl;
} wifi_ieee80211_hdr_t;

typedef struct {
  wifi_ieee80211_hdr_t hdr;
  uint8_t payload[0];
} wifi_ieee80211_packet_t;

// ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
static uint32_t crc32_simple(const uint8_t* p, size_t n){
  uint32_t c=0xFFFFFFFF;
  for(size_t i=0;i<n;i++){ c ^= p[i]; for(int k=0;k<8;k++) c = (c>>1) ^ (0xEDB88320 & (-(int)(c & 1))); }
  return ~c;
}

static void macToStr(const uint8_t mac[6], char out[18]){
  sprintf(out,"%02X:%02X:%02X:%02X:%02X:%02X",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
}

bool ensurePeer(const uint8_t mac[6], bool encrypt=false){
  esp_now_peer_info_t peer{};
  memcpy(peer.peer_addr, mac, 6);
  peer.ifidx = WIFI_IF_STA;
  peer.channel = WIFI_CH;
  peer.encrypt = encrypt;
  if (esp_now_is_peer_exist(mac)) return true;
  esp_err_t r = esp_now_add_peer(&peer);
  if (r != ESP_OK) {
    char m[18]; macToStr(mac,m);
    Serial.printf("[ERR] add_peer %s -> %d\n", m, r);
  }
  return r == ESP_OK;
}

// å—ä¿¡ã—ãŸå…¨Wi-Fiãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ RSSI ã¨ é€ä¿¡å…ƒMAC ã‚’æ‹¾ã†
static void IRAM_ATTR promiscuous_rx_cb(void* buf, wifi_promiscuous_pkt_type_t type) {
  if (type != WIFI_PKT_MGMT && type != WIFI_PKT_DATA) return;
  const wifi_promiscuous_pkt_t* ppkt = (const wifi_promiscuous_pkt_t*)buf;
  const wifi_ieee80211_packet_t* ipkt = (const wifi_ieee80211_packet_t*)ppkt->payload;
  
  // MACã”ã¨ã«RSSIã‚’è¨˜éŒ²
  int rssi = (int)ppkt->rx_ctrl.rssi;
  upsertRssi(ipkt->hdr.addr2, rssi);
  
  // å¾Œæ–¹äº’æ›ç”¨ï¼ˆæœ€å¾Œã®RSSIï¼‰
  lastRSSI = rssi;
  memcpy((void*)lastRssiMac, ipkt->hdr.addr2, 6);
  lastRssiValid = true;
}

// â˜… æ–°ã—ã„äº¤æ›ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã¯ã˜ã‚ã‚‹ï¼ˆmsg_idã‚’å¢—ã‚„ã™ï¼‰
// startNewExchange()ã¯å‰Šé™¤ï¼ˆTURNæ–¹å¼ã§è‡ªå‹•çš„ã«å½¹å‰²äº¤ä»£ï¼‰

String loadJsonFromLittleFS(const char* path, size_t maxBytes){
  if (!LittleFS.begin(true)) {
    Serial.println("[LittleFS] mount failedï¼ˆformat=trueã§å†è©¦è¡Œï¼‰");
  }
  if (!LittleFS.exists(path)) {
    Serial.printf("[LittleFS] %s not found. Use default sample.\n", path);
    return String(R"({"id":"393235","flag":"photo","note":"default because /payload.json not found"})");
  }
  File f = LittleFS.open(path, "r");
  if (!f || f.isDirectory()) {
    Serial.printf("[LittleFS] open failed: %s\n", path);
    return String(R"({"error":"open failed"})");
  }
  size_t n = f.size();
  if (n > maxBytes) {
    Serial.printf("[LittleFS] file too large (%u > %u). Truncating.\n", (unsigned)n, (unsigned)maxBytes);
    n = maxBytes;
  }
  String s; s.reserve(n);
  while (f.available() && s.length() < (int)n) s += (char)f.read();
  f.close();
  Serial.printf("[LittleFS] loaded %u bytes from %s\n", (unsigned)s.length(), path);
  return s;
}

// ===== LEDãƒãƒˆãƒªã‚¯ã‚¹æç”»é–¢æ•° =====
// åæ™‚è¨ˆå›ã‚Š90Â°å›è»¢ã§æç”»
static void drawRGBArrayRotCCW(const uint8_t* rgb, size_t n) {
  if (n < NUM_LEDS * 3) return;
  matrix.fillScreen(0);
  for (int srcY = 0; srcY < H; srcY++) {
    for (int srcX = 0; srcX < W; srcX++) {
      size_t srcIndex = (srcY * W + srcX) * 3;
      uint8_t r = rgb[srcIndex + 0];
      uint8_t g = rgb[srcIndex + 1];
      uint8_t b = rgb[srcIndex + 2];
      int dstX = srcY;
      int dstY = W - 1 - srcX;
      matrix.drawPixel(dstX, dstY, matrix.Color(r, g, b));
    }
  }
  matrix.show();
}

// å—ä¿¡JSONï¼ˆãƒãƒƒãƒ•ã‚¡ï¼‰ã‹ã‚‰ rgb é…åˆ—ã‚’è¦‹ã¤ã‘ã¦æç”»
static bool renderFromJson(const uint8_t* buf, size_t len) {
  // JSONãŒ1KBã€œæ•°KBã«ãªã‚Šã†ã‚‹ã®ã§å°‘ã—ä½™è£•ã‚’ç¢ºä¿
  DynamicJsonDocument doc(8192);
  DeserializationError err = deserializeJson(doc, buf, len);
  if (err) {
    Serial.println("âŒ JSONè§£æã‚¨ãƒ©ãƒ¼");
    return false;
  }

  // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šæ˜ã‚‹ã•æŒ‡å®šãŒã‚ã‚Œã°åæ˜ ï¼ˆ0â€“255ï¼‰
  if (doc.containsKey("brightness")) {
    int br = doc["brightness"].as<int>();
    br = constrain(br, 0, 255);
    matrix.setBrightness(br);
  }

  // ãƒ‘ã‚¿ãƒ¼ãƒ³A: ç›´ä¸‹ã«rgbé…åˆ—
  JsonArray rgbA = doc["rgb"].is<JsonArray>() ? doc["rgb"].as<JsonArray>() : JsonArray();

  // ãƒ‘ã‚¿ãƒ¼ãƒ³B: records[0].rgb
  if (rgbA.isNull() && doc["records"].is<JsonArray>() && doc["records"][0]["rgb"].is<JsonArray>()) {
    rgbA = doc["records"][0]["rgb"].as<JsonArray>();
  }

  if (rgbA.isNull()) {
    Serial.println("âŒ RGBé…åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    return false;
  }

  // é•·ã•ãƒã‚§ãƒƒã‚¯ï¼ˆW*H*3ï¼‰
  const size_t need = NUM_LEDS * 3;
  if (rgbA.size() < need) {
    Serial.printf("âŒ RGBé…åˆ—ãŒçŸ­ã™ãã¾ã™: %u < %u\n", (unsigned)rgbA.size(), (unsigned)need);
    return false;
  }

  // ä¸€æ™‚ãƒãƒƒãƒ•ã‚¡ã«è©°ã‚ã‚‹ï¼ˆå¿…è¦åˆ†ã ã‘ï¼‰
  static uint8_t rgbBuf[NUM_LEDS * 3];
  for (size_t i = 0; i < need; ++i) {
    rgbBuf[i] = (uint8_t) rgbA[i].as<int>();
  }

  drawRGBArrayRotCCW(rgbBuf, need);
  Serial.println("âœ… è¡¨ç¤ºå®Œäº†");
  
  // 5ç§’å¾Œã«æ¶ˆç¯ã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚»ãƒƒãƒˆ
  ledDisplayUntil = millis() + 5000;
  
  return true;
}

// ===== é€ä¿¡é–¢æ•° =====
void sendHELLO(){
  if (!broadcastPeerAdded) {
    ensurePeer(MAC_BC,false); // åˆå›ã®ã¿è¿½åŠ 
    broadcastPeerAdded = true;
  }
  FrameHello f{HELLO};
  esp_now_send(MAC_BC, (uint8_t*)&f, sizeof(f));
  // Serial.println("[TX] HELLO (broadcast)");  // å‰Šé™¤ï¼ˆé »ç¹ã™ãã‚‹ï¼‰
}

void sendMETA(const uint8_t mac[6]){
  FrameMeta m{};
  m.type = META;
  m.msg_id = current_msg_id;
  m.total = tx_total;
  m.len_all = tx_len_all;
  m.crc32_all = tx_crc;
  ensurePeer(mac,false);
  esp_now_send(mac, (uint8_t*)&m, sizeof(m));
  // char mm[18]; macToStr(mac, mm);
  // Serial.printf("[TX] META -> %s total=%u len=%u crc=0x%08X\n", mm, m.total, m.len_all, m.crc32_all);
  lastProgressMs = millis();
}

void sendCHUNK(const uint8_t mac[6], uint16_t idx){
  FrameChunk c{};
  c.type   = CHUNK;
  c.msg_id = current_msg_id;
  c.idx    = idx;

  size_t off = (size_t)idx * CHUNK_DATA_MAX;
  size_t remain = (tx_len_all > off) ? (tx_len_all - off) : 0;
  size_t n = remain > CHUNK_DATA_MAX ? CHUNK_DATA_MAX : remain;

  memcpy(c.data, tx_json.c_str() + off, n);
  c.payload_len = (uint16_t)n;

  esp_now_send(mac, (uint8_t*)&c, sizeof(c.type)+2+2+2 + n);
  // if (idx % 8 == 0) {
  //   char mm[18]; macToStr(mac, mm);
  //   Serial.printf("[TX] CHUNK idx=%u len=%u -> %s\n", idx, c.payload_len, mm);
  // }
  lastProgressMs = millis();
}

void sendACK(const uint8_t mac[6], uint16_t msg_id){
  ensurePeer(mac, false);                 // â˜…ä¿é™ºã® peer ç™»éŒ²
  FrameAck a{ACK, msg_id};
  for (int i=0; i<3; i++){                // â˜…3é€£æŠ•ï¼ˆé›»æ³¢è½ã¡ä¿é™ºï¼‰
    esp_now_send(mac, (uint8_t*)&a, sizeof(a));
    delay(2);
  }
  // char mm[18]; macToStr(mac, mm);
  // Serial.printf("[TX] ACK -> %s (msg=%u)\n", mm, msg_id);
}

void sendNACK(const uint8_t mac[6], uint16_t msg_id, uint16_t missing_idx){
  ensurePeer(mac, false);                 // â˜…ä¿é™ºã® peer ç™»éŒ²
  FrameNack n{NACK, msg_id, missing_idx};
  esp_now_send(mac, (uint8_t*)&n, sizeof(n));
  lastProgressMs = millis();
}

void sendTURN(const uint8_t mac[6], uint16_t msg_id) {
  ensurePeer(mac, false);                 // â˜…ä¿é™ºã® peer ç™»éŒ²
  FrameTurn t{TURN, msg_id};
  esp_now_send(mac, (uint8_t*)&t, sizeof(t));
  Serial.println("ğŸ”„ TURN é€ä¿¡ï¼ˆæ¨©åˆ©è­²æ¸¡ï¼‰");
}

// ===== é€ä¿¡ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ï¼ˆå”¯ä¸€ã®å…¥å£ï¼‰ =====
bool startTxSession(){  // â˜… æˆ»ã‚Šå€¤boolï¼šæœ¬å½“ã«é€ä¿¡é–‹å§‹ã—ãŸã‹
  Serial.println("ğŸ“¡ é€ä¿¡ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹");
  
  // msg_idæ›´æ–°
  current_msg_id++;
  if (current_msg_id == 0) current_msg_id = 1;
  
  // é€ä¿¡ãƒ‡ãƒ¼ã‚¿æº–å‚™
  tx_json = myJson;
  if (tx_json.length() > MAX_MSG_BYTES) {
    tx_json = tx_json.substring(0, MAX_MSG_BYTES);
  }
  tx_len_all = tx_json.length();
  tx_crc     = crc32_simple((const uint8_t*)tx_json.c_str(), tx_len_all);
  tx_total   = (tx_len_all + CHUNK_DATA_MAX - 1) / CHUNK_DATA_MAX;
  nextIdx = 0;
  tx_done = false;
  tx_meta_sent = false;  // â† ãƒªã‚»ãƒƒãƒˆ

  // METAé€ä¿¡
  ensurePeer(peerMac, false);  // å¿µã®ãŸã‚
  sendMETA(peerMac);
  lastSendMs = millis();
  tx_meta_sent = true;  // â† METAã‚’ç¢ºå®Ÿã«é€ã£ãŸ
  Serial.printf("ğŸŸ¢ METAé€ä¿¡: msg=%u total=%u len=%u\n", current_msg_id, tx_total, tx_len_all);

  // å…ˆé ­ãƒãƒ¼ã‚¹ãƒˆï¼ˆ6å€‹ï¼‰
  uint16_t burst = min<uint16_t>(tx_total, 6);
  for(uint16_t i=0;i<burst;i++){
    sendCHUNK(peerMac, i);
    delay(3);
  }
  
  return true;  // â† é€ä¿¡é–‹å§‹OK
}

// ===== å—ä¿¡ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ =====
void startRxSession(const FrameMeta* m){
  Serial.println("ğŸ“¥ å—ä¿¡ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹");
  
  // ãƒ¬ãƒ¼ãƒ€ãƒ¼ã‚’åœæ­¢
  matrix.fillScreen(0);
  matrix.show();

  // å—ä¿¡çŠ¶æ…‹ã‚’åˆæœŸåŒ–
  memset(&rx, 0, sizeof(rx));
  rx.active = true;
  rx.msg_id = m->msg_id;
  rx.total  = m->total;
  rx.len_all= m->len_all;
  rx.crc32_all = m->crc32_all;

  lastProgressMs = millis();
}

// ===== æ¬¡ãƒãƒ£ãƒ³ã‚¯é€ä¿¡ =====
void sendNextChunk(){
  if (nextIdx < tx_total){
    sendCHUNK(peerMac, nextIdx++);
    lastSendMs = millis();
  }
}


// ===== ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ =====
void onSend(const uint8_t* mac, esp_now_send_status_t s){
  // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ­ã‚°ã¯å‰Šé™¤ï¼ˆé »ç¹ã™ãã‚‹ï¼‰
  // char mm[18]; macToStr(mac, mm);
  // Serial.printf("[CALLBACK] onSend -> %s status=%s\n", mm, s==ESP_NOW_SEND_SUCCESS?"SUCCESS":"FAIL");
  lastTrafficMs = millis(); // â˜… é€ä¿¡æˆåŠŸã‚‚ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã¨ã—ã¦æ‰±ã†
}

void onRecv(const uint8_t* mac, const uint8_t* data, int len){
  char mm[18]; macToStr(mac, mm);

  // === MACã”ã¨ã®RSSIã‚’å–å¾—ï¼ˆå¼¾ã‹ãªã„ï¼‰ ===
  int rssi = -100;
  bool hasRssi = getRssiForMac(mac, &rssi);

  // â˜… å—ä¿¡ãŒã‚ã£ãŸï¼ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒç”Ÿãã¦ã„ã‚‹
  lastTrafficMs = millis();

  if (len <= 0) return;
  uint8_t t = data[0];

  // ===== HELLOï¼šæ¢ã™ï¼†å½¹å‰²é¸æŒ™ã®ã¿ï¼ˆå¼¾ã‹ãªã„ãƒ»å†é¸æŒ™ç¦æ­¢ï¼‰ =====
  if (t == HELLO){
    // ç›¸æ‰‹ç™ºè¦‹ãƒ­ã‚°ã®ã‚¹ãƒ‘ãƒ æŠ‘åˆ¶
    unsigned long nowms = millis();
    if (nowms - lastFoundLogMs > FOUND_LOG_DEBOUNCE) {
      const char* distance = 
        (rssi > -50) ? "éå¸¸ã«è¿‘ã„" :
        (rssi > -60) ? "è¿‘ã„" :
        (rssi > -70) ? "ä¸­è·é›¢" :
        (rssi > -80) ? "é ã„" : "éå¸¸ã«é ã„";
      Serial.printf("ğŸ” ç›¸æ‰‹ç™ºè¦‹: %s | RSSI: %d dBm (%s)\n", mm, rssi, distance);
      lastFoundLogMs = nowms;
    }

    // æ—¢ã«ãƒšã‚¢ç¢ºå®šãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆå†é¸æŒ™ã—ãªã„ï¼‰
    if (hasPeer) return;

    // ãƒšã‚¢æˆç«‹ï¼†å½¹å‰²é¸æŒ™ï¼ˆä¸€åº¦ã ã‘ï¼‰
    memcpy(peerMac, mac, 6);
    
    uint8_t selfMac[6]; 
    esp_wifi_get_mac(WIFI_IF_STA, selfMac);
    
    isInitiator = (memcmp(selfMac, mac, 6) < 0);
    txRight = isInitiator;  // åˆæ‰‹ï¼šInitiatorã«é€ä¿¡æ¨©
    hasPeer = true;
    
    ensurePeer(peerMac, false); // â˜… ãƒšã‚¢ç™»éŒ²
    
    Serial.printf("ğŸ¯ å½¹å‰²æ±ºå®š: %s (MACæ¯”è¼ƒ)\n", 
                  isInitiator ? "Initiator(é€ä¿¡)" : "Responder(å—ä¿¡)");
    
    // â˜… è¿½åŠ ï¼šè‡ªåˆ†ãŒResponderãªã‚‰ã€ä¸€åº¦ã ã‘TURNã‚’é€ã£ã¦ç›¸æ‰‹ã‚’ã‚­ãƒƒã‚¯
    static bool kickSent = false;
    if (!isInitiator && !kickSent) {
      sendTURN(peerMac, 0);
      kickSent = true;
      Serial.println("ğŸ”” KICK: Responderâ†’Initiator ã« TURN é€ä¿¡");
    }
    
    return;
  }

  // ===== HELLOä»¥å¤–ã¯ç›¸æ‰‹ç¢ºå®šå¾Œã«å³æ ¼ãƒ•ã‚£ãƒ«ã‚¿ =====
  if (hasPeer && memcmp(mac, peerMac, 6) != 0) {
    return; // ä»–äººã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ç„¡è¦–
  }

  // ===== METAï¼šå—ä¿¡å´ã®ã¿åå¿œ =====
  if (t == META && len >= (int)sizeof(FrameMeta)){
    if (!txRight) {  // â˜… è‡ªåˆ†ãŒå—ä¿¡å´ã®æ™‚ã ã‘
      const FrameMeta* m = (const FrameMeta*)data;
      startRxSession(m);
    }
    return;
  }

  // ===== CHUNKï¼šå—ä¿¡ä¸­ã®ã¿å–ã‚Šè¾¼ã¿ï¼ˆNACKé§†å‹•ï¼‰ =====
  if (t == CHUNK && len >= (int)(sizeof(uint8_t)+2+2+2)){
    const FrameChunk* c = (const FrameChunk*)data;

    if (!rx.active || c->msg_id != rx.msg_id) {
      return;  // ç„¡è¦–ï¼ˆå­¤å…CHUNKã¯æ”¾ç½®ï¼‰
    }

    // é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—
    if (c->idx < MAX_CHUNKS && rx.got[c->idx]) {
      lastProgressMs = millis();
      return;
    }

    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (c->idx >= rx.total || c->payload_len > CHUNK_DATA_MAX) {
      return;
    }

    size_t off = (size_t)c->idx * CHUNK_DATA_MAX;
    size_t can = rx.len_all - off;
    if (c->payload_len > can) {
      return;
    }

    // ãƒ‡ãƒ¼ã‚¿å–ã‚Šè¾¼ã¿
    memcpy(rx.buf + off, c->data, c->payload_len);
    if (!rx.got[c->idx]) { rx.got[c->idx] = true; rx.gotCount++; }

    // é€²æ—è¡¨ç¤ºï¼ˆ10%åˆ»ã¿ï¼‰
    static uint16_t lastReportedPercent = 0;
    uint16_t percent = (rx.gotCount * 100) / rx.total;
    if (percent >= lastReportedPercent + 10 || rx.gotCount == rx.total) {
      Serial.printf("ğŸ“¦ å—ä¿¡ä¸­: %u%%\n", percent);
      lastReportedPercent = percent;
    }

    lastProgressMs = millis();


    // æ¬ è½ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®1å€‹ã ã‘NACKï¼‰
    if (rx.gotCount < rx.total){
      for(uint16_t i=0;i<rx.total;i++){
        if (!rx.got[i]){
          // ã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°ï¼ˆ30msé–“éš”ï¼‰
          unsigned long nowms = millis();
          if (!(rx.lastNackTxIdx == i && (nowms - rx.lastNackTxAt) < 30)) {
            sendNACK(mac, rx.msg_id, i);
            rx.lastNackTxIdx = i;
            rx.lastNackTxAt  = nowms;
          }
          break;  // æœ€åˆã®æ¬ è½ã®ã¿
        }
      }
    } else {
      // å…¨éƒ¨æƒã£ãŸ â†’ CRCç¢ºèª
      uint32_t csum = crc32_simple(rx.buf, rx.len_all);
      if (csum == rx.crc32_all){
        sendACK(mac, rx.msg_id);
        lastAckSentAt = millis();         // â˜…ACKå†é€ç”¨ã‚¿ã‚¤ãƒè¨˜éŒ²
        lastAckMsgId  = rx.msg_id;        // â˜…ACKå†é€ç”¨msg_idè¨˜éŒ²
        Serial.println("âœ… å—ä¿¡å®Œäº†");
        
        // å—ä¿¡å®Œäº†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        Ripple_PlayOnce();
        
        renderFromJson(rx.buf, rx.len_all);   // å—ä¿¡JSONã‹ã‚‰LEDã«æç”»

        rx.active = false;
        lastReportedPercent = 0;  // ãƒªã‚»ãƒƒãƒˆ
      } else {
        Serial.println("âŒ CRCã‚¨ãƒ©ãƒ¼ - æœ€åˆã‹ã‚‰å†é€è¦æ±‚");
        sendNACK(mac, rx.msg_id, 0);
      }
    }
    return;
  }

  // ===== NACKï¼šé€ä¿¡å´ãŒæŒ‡å®šidxã ã‘å†é€ =====
  if (t == NACK && len >= (int)sizeof(FrameNack)){
    const FrameNack* n = (const FrameNack*)data;

    // é‡è¤‡æŠ‘åˆ¶ï¼ˆ50msï¼‰
    unsigned long nowms = millis();
    if (n->msg_id == lastNackMsg && n->missing_idx == lastNackIdx && (nowms - lastNackAt) < 50) {
      return;
    }
    lastNackMsg = n->msg_id; lastNackIdx = n->missing_idx; lastNackAt = nowms;

    if (n->msg_id == current_msg_id && n->missing_idx < tx_total){
      sendCHUNK(mac, n->missing_idx);
      // è¿‘å‚1å€‹ã‚‚è£œåŠ©å†é€
      if (n->missing_idx + 1 < tx_total) sendCHUNK(mac, n->missing_idx + 1);
    }
    lastProgressMs = millis();
    return;
  }

  // ===== ACKï¼šé€ä¿¡å®Œäº† â†’ TURNé€ä¿¡ï¼ˆåŒæ–¹å‘ãƒ»ç¢ºå®Ÿã«ï¼‰ =====
  if (t == ACK && len >= (int)sizeof(FrameAck)){
    const FrameAck* a = (const FrameAck*)data;
    if (a->msg_id == current_msg_id){
      tx_done = true;
      Serial.println("âœ… é€ä¿¡å®Œäº†");

      // ç›¸æ‰‹ã¸æ¨©åˆ©è­²æ¸¡
      sendTURN(peerMac, current_msg_id);
      txRight = false;      // è‡ªåˆ†ã¯æ¨©åˆ©æ”¾æ£„
      txLaunched = false;   // è‡ªåˆ†ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯çµ‚äº†
    }
    lastProgressMs = millis();
    return;
  }

  // ===== TURNï¼šæ¨©åˆ©ç²å¾—ï¼ˆæ¬¡ãƒ«ãƒ¼ãƒ—ã§é€ä¿¡é–‹å§‹ã¸ï¼‰ =====
  if (t == TURN && len >= (int)sizeof(FrameTurn)){
    // ã¾ã ãƒšã‚¢ä¸æ˜ãªã‚‰ã“ã“ã§ç¢ºå®šï¼ˆTURNã§åˆæµã§ãã‚‹ï¼‰
    if (!hasPeer) {
      memcpy(peerMac, mac, 6);
      uint8_t selfMac[6]; 
      esp_wifi_get_mac(WIFI_IF_STA, selfMac);
      isInitiator = (memcmp(selfMac, mac, 6) < 0);
      hasPeer = true;
      ensurePeer(peerMac, false);
      Serial.println("ğŸ¤ TURNã§ãƒšã‚¢ç¢ºå®š");
    }
    
    Serial.println("ğŸ”„ TURN å—ä¿¡ï¼ˆæ¨©åˆ©ç²å¾—ï¼‰");
    txRight = true;         // æ¨©åˆ©ç²å¾—
    txLaunched = false;     // â˜… é‡è¦ï¼šæ¬¡ã®loopã§startTxSession()ã‚’å‘¼ã¹ã‚‹çŠ¶æ…‹ã«
    
    // msg_idã¯é€ä¿¡å´ãŒæ›´æ–°ï¼ˆä»»æ„ã ãŒåˆ†ã‹ã‚Šã‚„ã™ãï¼‰
    current_msg_id++;
    if (current_msg_id == 0) current_msg_id = 1;
    
    return;
  }

  // Serial.printf("[RX] Unknown type=%u len=%d from %s\n", t, len, mm);
}

// ===== ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—/ãƒ«ãƒ¼ãƒ— =====
void setup(){
  Serial.begin(115200);
  delay(200);

  Serial.println("\n========================================");
  Serial.println("   ESP-NOW ãƒ‡ãƒ¼ã‚¿äº¤æ› & LEDè¡¨ç¤º");
  Serial.println("========================================\n");

  // === LEDãƒãƒˆãƒªã‚¯ã‚¹åˆæœŸåŒ– ===
  matrix.begin();
  matrix.setBrightness(GLOBAL_BRIGHTNESS);
  matrix.fillScreen(0);
  matrix.show();
  Serial.println("âœ… LEDãƒãƒˆãƒªã‚¯ã‚¹åˆæœŸåŒ–å®Œäº†");

  // èµ·å‹•æ™‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  Serial.println("ğŸ’« èµ·å‹•ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ...");
  Ripple_PlayOnce();

  // LittleFSã‹ã‚‰JSONã‚’ãƒ­ãƒ¼ãƒ‰
  myJson = loadJsonFromLittleFS(JSON_PATH, MAX_MSG_BYTES);
  Serial.printf("ğŸ“„ JSONèª­è¾¼: %u ãƒã‚¤ãƒˆ\n", (unsigned)myJson.length());

  // èµ·å‹•æ™‚ã«è‡ªåˆ†ã®JSONã§æç”»ï¼ˆä»»æ„ï¼‰
  Serial.println("ğŸ’¡ èµ·å‹•æ™‚è¡¨ç¤º...");
  renderFromJson((const uint8_t*)myJson.c_str(), myJson.length());

  // Wi-Fi/ESP-NOWåˆæœŸåŒ–
  WiFi.mode(WIFI_STA);

  // ï¼ˆä»»æ„ï¼‰å›½è¨­å®šï¼šæ—¥æœ¬
  wifi_country_t ctry = { .cc="JP", .schan=1, .nchan=13, .max_tx_power=20, .policy=WIFI_COUNTRY_POLICY_MANUAL };
  esp_wifi_set_country(&ctry);

  // â˜… ãƒ—ãƒ­ãƒŸã‚¹ã‚­ãƒ£ã‚¹ã‚’å¸¸æ™‚ONã«ã—ã¦RSSIã‚’å–ã‚‹
  wifi_promiscuous_filter_t filt;
  filt.filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT | WIFI_PROMIS_FILTER_MASK_DATA;
  esp_wifi_set_promiscuous_filter(&filt);
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(&promiscuous_rx_cb);

  // å›ºå®šãƒãƒ£ãƒãƒ«
  esp_wifi_set_channel(WIFI_CH, WIFI_SECOND_CHAN_NONE);

  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ ESP-NOWåˆæœŸåŒ–å¤±æ•—");
    while(true){ delay(1000); }
  }
  Serial.println("âœ… ESP-NOWåˆæœŸåŒ–å®Œäº†");
  esp_now_register_send_cb(onSend);
  esp_now_register_recv_cb(onRecv);

  // èµ·å‹•æƒ…å ±ï¼ˆãƒãƒ£ãƒãƒ«/è‡ªMACï¼‰
  uint8_t ch; wifi_second_chan_t sc;
  esp_wifi_get_channel(&ch, &sc);
  Serial.printf("ğŸ“¡ MAC: %s | CH: %u\n\n", WiFi.macAddress().c_str(), ch);
  Serial.println("ğŸ” ç›¸æ‰‹ã‚’æ¢ã—ã¦ã„ã¾ã™...\n");

  // ç›¸æ‰‹æ¢ç´¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆãƒ¬ãƒ¼ãƒ€ãƒ¼åˆæœŸåŒ–ï¼‰
  Radar_InitIdle();

  // åˆæœŸHELLO
  lastHelloMs = millis() - 2000;  // èµ·å‹•ç›´å¾Œã«ä¸€åº¦HELLO
  lastProgressMs = millis();
  lastTrafficMs = millis();  // ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯æ™‚åˆ»ã®åˆæœŸåŒ–
}

void loop(){
  unsigned long now = millis();

  // LEDæ¶ˆç¯ã‚¿ã‚¤ãƒãƒ¼ãƒã‚§ãƒƒã‚¯ï¼ˆ5ç§’å¾Œã«æ¶ˆç¯ã—ã¦ãƒ¬ãƒ¼ãƒ€ãƒ¼å†é–‹ï¼‰
  if (ledDisplayUntil > 0 && now >= ledDisplayUntil) {
    matrix.fillScreen(0);
    matrix.show();
    Serial.println("ğŸ’¤ LEDæ¶ˆç¯");
    ledDisplayUntil = 0;
    
    // ãƒ¬ãƒ¼ãƒ€ãƒ¼å†é–‹ï¼ˆå—ä¿¡ä¸­ã§ãªã‘ã‚Œã°ï¼‰
    if (!rx.active) {
      Radar_InitIdle();
    }
  }

  // ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°ï¼ˆå—ä¿¡ä¸­ãƒ»è¡¨ç¤ºä¸­ä»¥å¤–ã¯å¸¸ã«è¡¨ç¤ºï¼‰
  bool shouldShowRadar = !rx.active && ledDisplayUntil == 0;
  if (shouldShowRadar) {
    Radar_IdleStep(true);
    delay(16);  // ç´„60fps
  }

  // ===== ã‚·ãƒ³ãƒ—ãƒ«4è¡Œãƒ«ãƒ¼ãƒ—ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³åˆ¶ï¼‰ =====
  
  // 1) HELLOï¼šãƒšã‚¢æœªæˆç«‹ã®é–“ã ã‘ 400msé–“éš”ã§é€ã‚‹
  if (!hasPeer && now - lastHelloMs > 400) {
    sendHELLO();
    lastHelloMs = now;
  }

  // 2) é€ä¿¡æ¨©ã‚ã‚Š & æœªé–‹å§‹ â†’ é€ä¿¡é–‹å§‹ï¼ˆè·é›¢ã‚²ãƒ¼ãƒˆå†…è”µãƒ»å†æŒ‘æˆ¦å¯èƒ½ï¼‰
  if (hasPeer && txRight && !txLaunched) {
    bool started = startTxSession();  // å®Ÿéš›ã«è¹´ã‚ŒãŸã‹
    if (started && tx_meta_sent) {
      txLaunched = true;              // æœ¬å½“ã«METAã‚’å‡ºã›ãŸæ™‚ã ã‘true
      Serial.println("ğŸš€ é€ä¿¡é–‹å§‹ãƒ•ãƒ©ã‚° txLaunched=true");
    } else {
      // æœªé–‹å§‹ï¼ˆè·é›¢NGãªã©ï¼‰â†’ æ¬¡ãƒ«ãƒ¼ãƒ—ã§å†æŒ‘æˆ¦ï¼ˆtxLaunchedã¯falseã®ã¾ã¾ï¼‰
    }
  }

  // 3) é€ä¿¡ä¸­ï¼š35msé–“éš”ã§æ¬¡ãƒãƒ£ãƒ³ã‚¯ã‚’é€ã‚‹
  if (hasPeer && !tx_done && txLaunched && now - lastSendMs > 35) {
    sendNextChunk();
  }

  // 4) ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šTURNå–ªå¤±æ™‚ã®ä¿é™ºï¼ˆä»»æ„ãƒ»è»½é‡ï¼‰
  static unsigned long lastActivityCheck = 0;
  if (hasPeer && !txRight && !rx.active && (now - lastActivityCheck > 2000)) {
    // ç›¸æ‰‹ã®ç•ªãŒé•·ãæ­¢ã¾ã£ã¦ã„ã‚‹ â†’ è»½ãHELLOã‚’1ç™ºé€ã£ã¦å†åŒæœŸ
    // ï¼ˆé€šå¸¸ã¯ä¸è¦ã ãŒã€TURNã ã‘è½ã¡ãŸæ™‚ã®ä¿é™ºï¼‰
    lastActivityCheck = now;
  }
  
  // 5) ACKå†é€ï¼šResponderãŒå—ä¿¡å®Œäº†ã—ãŸã®ã«TURNãŒæ¥ãªã„å ´åˆã®ä¿é™º
  if (!txRight && !rx.active && lastAckMsgId != 0 && now - lastAckSentAt > 400) {
    // TURNãŒæ¥ãªã„ï¼ç›¸æ‰‹ãŒACKã‚’è½ã¨ã—ãŸç–‘ã„
    sendACK(peerMac, lastAckMsgId);     // 3é€£æŠ•ãƒãƒ¼ã‚¹ãƒˆç‰ˆãŒå‘¼ã°ã‚Œã‚‹
    lastAckSentAt = now;
    Serial.println("ğŸ“£ ACKå†é€ï¼ˆTURNå¾…ã¡ï¼‰");
  }
}
